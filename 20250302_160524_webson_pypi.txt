# PyPI Package: webson

Version: 0.1.6
Summary: Turn any webpage into structured outputs!
Author: Unknown (Arthur Brenno <64020210+arthurbrenno@users.noreply.github.com>)
License: Unknown

## Description

# Webson ðŸ•¸ï¸

**Turn any webpage into structured outputs!** âš¡ï¸  
*Extract data from any website with the power of AI.*

---

## âœ¨ Overview

Webson is a cutting-edge tool that transforms webpages into structured data models â€” all with just a few lines of code. No more manual scraping or complex parsers! With Webson, you can effortlessly convert HTML into meaningful, actionable insights using state-of-the-art Language Models (LLMs) from IntelliBricks and robust automation powered by Playwright.

---

## ðŸŽ¯ Key Features

- **ðŸ¦¾ Intelligent Data Extraction:**  
  Convert webpages into structured data using your own defined models.  
  *(Say goodbye to messy HTML!)*

- **ðŸ’¬ Chat Casting:**  
  Simply tell Webson what you need in plain language, and it will extract and structure the data for you.  
  *(Example: "Extract product details from https://amazon.com and shopee.com including title, price, and rating.")*

- **âš¡ï¸ Seamless Integration:**  
  Built on top of [IntelliBricks](https://arthurbrenno.github.io/intellibricks/) and [Playwright](https://playwright.dev/python/docs/intro) â€” enjoy a Python-first approach without the boilerplate.

- **ðŸ“Š Structured Outputs:**  
  Define your output schemas with `msgspec.Struct` and get data back in a ready-to-use, strongly typed format.

---

## ðŸš€ Installation

Install Webson and its dependencies via pip:

```bash
pip install webson
```

**Important:** Webson relies on [Playwright](https://playwright.dev/python/docs/intro) for web automation. This happens because we all know that many pages rely on things that only happen in a browser, like loading stripts, styles, etc. Follow these steps to install Playwright and its browser dependencies:

1. **Install Playwright:**

    ```bash
    pip install playwright
    ```

2. **Install Browser Binaries:**

    ```bash
    playwright install
    ```

Now youâ€™re all set to transform any webpage into structured intelligence!

---

## ðŸ”§ Usage Examples

### 1. Casting a Webpage into a Structured Model

Define your own data model and cast a webpageâ€™s content into it:

```python
import msgspec
from intellibricks.llms import Synapse
from webson import Webson
from typing import Annotated

# Define your desired structured model
class PageSummary(msgspec.Struct):
    title: str
    summary: Annotated[
      str,
      msgspec.Meta(
        description="A short summary of the page")
    ]

# Initialize your LLM (using IntelliBricks Synapse) and Webson
llm = Synapse.of("google/genai/gemini-pro-experimental")
webson = Webson(llm=llm, timeout=5000)

# Cast the webpage content into your structured model
structured_data = webson.cast(PageSummary, "https://example.com")
print(f"Title: {structured_data.title}")
print(f"Content: {structured_data.summary}")
```

### 2. High-Level Query to Struct

Simply describe what you need and let Webson do the heavy lifting:

```python
from intellibricks.llms import Synapse
from webson import Webson

# Initialize your LLM and Webson instance
llm = Synapse.of("google/genai/gemini-pro-experimental")
webson = Webson(llm=llm, timeout=5000)

# Use natural language to instruct Webson on what data to extract
results = webson.query_to_struct(
    "Extract product info from https://amazon.com and https://www.walmart.com/ including title, price, and rating."
)
for url, output in results:
    print(url, output)
```

---

## âš™ï¸ How It Works

1. **Webpage Automation:**  
   Webson uses Playwright to open webpages in a headless browser and retrieve the HTML content.

2. **Markdown Conversion:**  
   The raw HTML is converted into Markdown for improved text processing and parsing.

3. **LLM-Powered Casting:**  
   The transformed Markdown is sent to your LLM (via IntelliBricks) which then returns structured data based on your specified schema.

---

## ðŸ¤ Contributing

We welcome contributions to make Webson even more awesome!  
If you encounter any issues or have ideas for new features, please open an issue or submit a pull request on our [GitHub repository](https://github.com/your-repo/webson).

---

## ðŸ“œ License

This project is licensed under the [APACHE 2.0 License](LICENSE).

---


## Dependencies

- architecture>=0.5.44
- intellibricks>=0.7.24
- markdownify>=0.14.1
- msgspec>=0.19.0
- playwright>=1.49.1
- requests>=2.32.3


## Classifiers



## Package Content


## File: webson-0.1.6/tests/example.py
```python
from webson import Webson
from intellibricks.llms import Synapse
import msgspec
from architecture import log

debug_logger = log.create_logger(__name__, log.DEBUG)


class Edital(msgspec.Struct):
    titulo: str
    link: str


class EditaisResult(msgspec.Struct):
    editais: list[Edital]


webson = Webson(llm=Synapse.of("google/genai/gemini-1.5-flash"))

result = webson.cast(EditaisResult, "https://prosas.com.br/editais")

debug_logger.debug(result)

```


## File: webson-0.1.6/scripts/release.py
```python
import os
import re
import shutil
import subprocess
import sys
import signal
from enum import Enum, auto
from typing import List, Optional

import msgspec
import questionary
import toml
import tomlkit
from questionary.prompts.common import Choice
from rich.console import Console
from rich.markdown import Markdown
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.theme import Theme
from rich.traceback import install

install()  # Better traceback formatting with Rich

# Force Python's default SIGINT handler so Ctrl+C isn't swallowed
signal.signal(signal.SIGINT, signal.SIG_DFL)


def parse_version(version: str) -> list[int]:
    """Parse a string version like 'v0.1.2' into a list of ints [0,1,2]."""
    return list(map(int, version.lstrip("v").split(".")))


def compare_releases(version1: str, version2: str) -> int:
    """Compare two version strings ('v0.1.2'). Return -1, 0, or 1."""
    parsed_version1 = parse_version(version1)
    parsed_version2 = parse_version(version2)
    if parsed_version1 < parsed_version2:
        return -1
    elif parsed_version1 > parsed_version2:
        return 1
    else:
        return 0


class ReleaseType(Enum):
    MAJOR = auto()
    FEATURE = auto()
    PATCH = auto()


def clear_console() -> None:
    """Clear the console screen."""
    os.system("cls" if os.name == "nt" else "clear")


def display_ascii_art():
    """Display an ASCII art title with gradient."""
    from rich.text import Text
    from pyfiglet import Figlet

    f = Figlet(font="big")
    ascii_art = f.renderText("Webson")
    console.print(Text(ascii_art, style="bold magenta"), justify="center")


# Define console with custom theme
custom_theme = Theme(
    {
        "success": "bold green",
        "error": "bold red",
        "question": "bold cyan",
        "info": "cyan",
        "warning": "bold yellow",
    }
)
console = Console(theme=custom_theme)


def run_command(
    cmd: List[str],
    description: str,
    acceptable_exit_codes: Optional[List[int]] = None,
    success_output_patterns: Optional[List[str]] = None,
):
    """Run a system command with progress indication and error handling."""
    acceptable_exit_codes = acceptable_exit_codes or [0]
    success_output_patterns = success_output_patterns or []
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        transient=True,
        console=console,
    ) as progress:
        task = progress.add_task(description)
        result = subprocess.run(cmd, capture_output=True, text=True)
        stdout_lower = result.stdout.lower()
        stderr_lower = result.stderr.lower()
        combined_output = stdout_lower + stderr_lower

        if result.returncode not in acceptable_exit_codes:
            # Check if any success pattern matches the output
            if any(
                re.search(pattern, combined_output)
                for pattern in success_output_patterns
            ):
                progress.update(task, completed=100)
                console.print(
                    f"[success]{description} completed successfully (handled non-zero exit code).[/success]"
                )
            else:
                progress.update(task, completed=100)
                console.print(Panel(f"Command {' '.join(cmd)} failed.", style="error"))
                console.print(
                    Panel(
                        f"[bold]STDOUT:[/bold]\n{result.stdout}\n[bold]STDERR:[/bold]\n{result.stderr}",
                        style="error",
                    )
                )
                raise subprocess.CalledProcessError(
                    result.returncode, cmd, output=result.stdout, stderr=result.stderr
                )
        else:
            progress.update(task, completed=100)
            console.print(f"[success]{description} completed successfully.[/success]")


def main():
    clear_console()
    display_ascii_art()

    # Loading animation while checking environment
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console,
    ) as progress:
        task = progress.add_task("Checking environment...", total=None)
        # Ensure GitHub CLI is installed
        gh_cli = shutil.which("gh")
        if not gh_cli:
            progress.stop()
            console.print(
                "[error]GitHub CLI ('gh') is required to run this script.[/error]"
            )
            raise ValueError("GitHub CLI ('gh') is required to run this script.")

        # Fetch latest release tag
        try:
            result = subprocess.run(
                [gh_cli, "release", "list", "--json", "tagName"],
                env={**os.environ, "GH_PAGER": "cat"},
                capture_output=True,
                text=True,
                check=True,
            )
            progress.update(
                task, description="Environment check completed.", completed=100
            )
        except subprocess.CalledProcessError as e:
            progress.stop()
            console.print("[error]Failed to fetch releases from GitHub.[/error]")
            raise e

    releases = msgspec.json.decode(result.stdout)

    # If no release found, ask user if they want to start from v0.0.1 or specify a custom version
    if not releases:
        console.print("[warning]No existing releases found on GitHub.[/warning]")
        version_choice = questionary.select(
            "No releases found. Do you want to use v0.0.1 or set your own version?",
            choices=["Use v0.0.1", "Specify my own version"],
        ).unsafe_ask()

        if version_choice is None:
            console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
            sys.exit(130)

        if version_choice == "Use v0.0.1":
            tag_version = "v0.0.1"
        else:
            custom_version = questionary.text(
                "Enter your custom version (e.g., v0.1.0):"
            ).unsafe_ask()
            if custom_version is None:
                console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
                sys.exit(130)
            if not custom_version.startswith("v"):
                custom_version = f"v{custom_version}"
            tag_version = custom_version
    else:
        tag_version = releases[0].get("tagName") if releases else "v0.0.0"

    # Release type selection with beautiful prompts
    console.print(
        Panel(
            Markdown("### What kind of release are you doing?"),
            title="Choose Release Type",
            title_align="left",
            border_style="blue",
        )
    )
    choices = [
        Choice(title="ðŸ› Patch", value=ReleaseType.PATCH),
        Choice(title="âœ¨ Feature", value=ReleaseType.FEATURE),
        Choice(title="ðŸš€ Major", value=ReleaseType.MAJOR),
    ]
    user_response = questionary.select(
        "",
        choices=choices,
        style=questionary.Style(
            [
                ("question", "fg:#00FF00 bold"),
                ("answer", "fg:#FFA500 bold"),
                ("pointer", "fg:#FF0000 bold"),
            ]
        ),
    ).unsafe_ask()

    if user_response is None:
        console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
        sys.exit(130)

    # Double confirmation for major or feature releases
    if user_response in [ReleaseType.MAJOR, ReleaseType.FEATURE]:
        for _ in range(2):
            confirm_result = questionary.confirm(
                f"Are you sure you want to proceed with a {user_response.name} release?",
                default=False,
                style=questionary.Style([("question", "fg:#FF69B4 bold")]),
            ).unsafe_ask()
            if confirm_result is None:
                console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
                sys.exit(130)

            if not confirm_result:
                console.print(
                    Panel(
                        "[warning]Release process terminated.[/warning]",
                        style="warning",
                    )
                )
                return

    # Load and update pyproject.toml
    pyproject = toml.load("pyproject.toml")
    project = pyproject.get("project", None)
    if not project or "version" not in project:
        console.print(
            Panel(
                "[error]The 'version' field is required in 'pyproject.toml'.[/error]",
                style="error",
            )
        )
        raise ValueError("The 'version' field is required in 'pyproject.toml'.")

    # Calculate new version
    parsed_version = parse_version(tag_version)
    if user_response == ReleaseType.MAJOR:
        parsed_version[0] += 1
        parsed_version[1] = 0
        parsed_version[2] = 0
    elif user_response == ReleaseType.FEATURE:
        parsed_version[1] += 1
        parsed_version[2] = 0
    else:
        parsed_version[2] += 1

    new_version = f"v{'.'.join(map(str, parsed_version))}"
    console.print(f"[info]New version calculated: {new_version}[/info]")

    # Git operations
    confirm_git_ops = questionary.confirm(
        "Add, commit, and push all changes before releasing?", default=True
    ).unsafe_ask()
    if confirm_git_ops is None:
        console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
        sys.exit(130)

    if confirm_git_ops:
        commands = [
            (["git", "add", "."], "Staging changes"),
            (
                ["git", "commit", "-m", new_version],
                f"Committing changes with message '{new_version}'",
            ),
            (["git", "push"], "Pushing changes to repository"),
        ]
        for cmd, description in commands:
            # For 'git commit', handle the 'nothing to commit' case
            if cmd[1] == "commit":
                run_command(
                    cmd,
                    description,
                    acceptable_exit_codes=[0, 1],
                    success_output_patterns=[r"nothing to commit"],
                )
            else:
                run_command(cmd, description)

    # Update pyproject.toml
    pyproject["project"]["version"] = new_version
    with open("pyproject.toml", "w") as f:
        f.write(tomlkit.dumps(pyproject))
    console.print(
        f"[success]Updated 'pyproject.toml' with new version {new_version}.[/success]"
    )

    # Ensure CHANGELOG.md exists
    changelog_path = "CHANGELOG.md"
    if not os.path.exists(changelog_path):
        with open(changelog_path, "w") as f:
            f.write("# Changelog\n\n")
        console.print(Panel(f"{changelog_path} created.", style="info"))
    else:
        # Check if the current version in CHANGELOG.md matches the new version
        with open(changelog_path, "r") as f:
            content = f.read()

        # Regex pattern to match version strings like v0.1.2 or v0.2.1
        match = re.search(r"#* v?(\d+\.\d+\.\d+)", content)

        if match:
            current_version = match.group(1).strip()
        else:
            current_version = "v0.0.0"  # Default version if no version header is found

        if current_version and new_version:
            if compare_releases(current_version, new_version) != 0:
                confirm_changelog_overwrite = questionary.confirm(
                    f"The version in {changelog_path} ({current_version}) does not match the new version ({new_version}). Do you want to overwrite the file?",
                    default=True,
                ).unsafe_ask()
                if confirm_changelog_overwrite is None:
                    console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
                    sys.exit(130)

                if confirm_changelog_overwrite:
                    with open(changelog_path, "w") as f:
                        f.write(f"# Changelog\n\n## {new_version}\n\n- \n")
                    console.print(
                        f"[info]Overwritten {changelog_path} with new version header.[/info]"
                    )
                else:
                    console.print("[info]Keeping existing CHANGELOG.md content.[/info]")
        else:
            console.print(
                f"[warning]Could not determine version from {changelog_path}. Overwriting with new version.[/warning]"
            )
            with open(changelog_path, "w") as f:
                f.write(f"# Changelog\n\n## {new_version}\n\n- \n")

    # Git commit and push for changes in pyproject.toml and CHANGELOG.md
    commands = [
        (["git", "add", "pyproject.toml", changelog_path], "Staging version changes"),
        (
            ["git", "commit", "-m", f"Release {new_version}"],
            f"Committing version changes with message 'Release {new_version}'",
        ),
        (["git", "push"], "Pushing version changes to repository"),
    ]
    for cmd, description in commands:
        # Handle 'git commit' with potential 'nothing to commit' message
        if cmd[1] == "commit":
            run_command(
                cmd,
                description,
                acceptable_exit_codes=[0, 1],
                success_output_patterns=[r"nothing to commit"],
            )
        else:
            run_command(cmd, description)

    # Create release using GitHub CLI
    release_title = questionary.text(
        "Enter the release title (this will appear as the heading of the release on GitHub). Leave blank to use the default version tag:",
        default=new_version,
    ).unsafe_ask()
    if release_title is None:
        console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
        sys.exit(130)

    extra_flags = questionary.text(
        "Enter additional GitHub CLI flags (optional):"
    ).unsafe_ask()
    if extra_flags is None:
        console.print("[warning]Prompt was cancelled. Exiting...[/warning]")
        sys.exit(130)

    try:
        gh_release_cmd = [
            gh_cli,
            "release",
            "create",
            new_version,
            "-F",
            changelog_path,
            "-t",
            release_title or new_version,
        ] + (extra_flags.split() if extra_flags else [])

        run_command(gh_release_cmd, f"Creating GitHub release {new_version}")
        console.print(
            Panel(
                f"Release [success]{new_version}[/success] created successfully!",
                style="success",
            )
        )
    except subprocess.CalledProcessError as e:
        console.print(Panel(f"Failed to create release: {e}", style="error"))


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        console.print("[warning]Received Ctrl+C! Exiting immediately...[/warning]")
        sys.exit(130)

```


## File: webson-0.1.6/src/webson/_types.py
```python
from typing import Any, Annotated

import msgspec


class JsonSchema(msgspec.Struct):
    schema: Annotated[
        dict[str, Any], msgspec.Meta(description="Stores the JSON schema object.")
    ]

```


## File: webson-0.1.6/src/webson/_functions.py
```python
import re


class URLNotFoundException(Exception):
    """Exception raised when no URL is found in the string."""

    pass


def find_urls_in_string(text: str) -> list[str]:
    """
    Finds all URLs within a given string and returns them as a list.

    This function uses a regular expression to identify URLs within the input string.
    It looks for common URL schemes like http://, https://, ftp://, and file://,
    followed by a domain and potentially a path, query parameters, and fragment.

    If no URL is found, a URLNotFoundException is raised.

    Args:
        text: The input string to search for URLs within.

    Returns:
        list[str]: A list containing all URLs found in the string.

    Raises:
        TypeError: If the input `text` is not a string.
        URLNotFoundException: If no URL is found in the string.

    Examples:
        >>> find_urls_in_string("Visit my website at https://www.example.com for more info.")
        ['https://www.example.com']

        >>> try:
        ...     find_urls_in_string("No URL here.")
        ... except URLNotFoundException:
        ...     print("No URL found!")
        No URL found!

        >>> find_urls_in_string("Check out http://example.org/path/to/resource?query=param#fragment")
        ['http://example.org/path/to/resource?query=param#fragment']

        >>> find_urls_in_string("Download the file from ftp://fileserver.com/pub/document.pdf")
        ['ftp://fileserver.com/pub/document.pdf']

        >>> find_urls_in_string("Local file path: file:///path/to/local/resource.txt")
        ['file:///path/to/local/resource.txt']

        >>> find_urls_in_string("Multiple URLs: https://example.com and http://example.org")
        ['https://example.com', 'http://example.org']

        >>> try:
        ...     find_urls_in_string("")
        ... except URLNotFoundException:
        ...     print("No URL found in empty string!")
        No URL found in empty string!
    """
    if not isinstance(text, str):
        raise TypeError("Input 'text' must be a string.")

    if not text:  # Handle empty strings efficiently
        raise URLNotFoundException("No URL found in empty string!")

    # Regular expression to find URLs
    url_pattern = re.compile(
        r"""
        \b                                  # Start at a word boundary
        (?:                                 # Non-capturing group for schemes
            https?://|                      # http:// or https://
            ftp://|                         # ftp://
            file:///                        # file:/// (local file paths)
        )
        (?:                                 # Non-capturing group for domain and path
            [-a-zA-Z0-9+&@#/%?=~_|!:,.;]*    # Domain, subdomains, and path characters
            [-a-zA-Z0-9+&@#/%=~_|]           # Allow one more character at the end (avoiding trailing punctuation)
        )
        \b                                  # End at a word boundary
        """,
        re.VERBOSE | re.IGNORECASE,
    )

    # Find all matching URLs in the text
    matches = url_pattern.findall(text)
    if matches:
        return matches
    else:
        raise URLNotFoundException(f"No URL found in the string: '{text}'")

```


## File: webson-0.1.6/src/webson/__init__.py
```python
"""Webson is a package that helps you convert any website to"""

from ._webson import Webson

__all__: list[str] = ["Webson"]

```


## File: webson-0.1.6/src/webson/_const.py
```python
SYSTEM_PROMPT = """
You are a helpful assistant.

** Task **
Your task is to convert webpages _(processed as markdown for clarity)_ into the desired structured output.
"""

```


## File: webson-0.1.6/src/webson/_webson.py
```python
"""Webson Module

This module provides the main functionality for the Webson package,
which leverages the IntelliBricks framework and Playwright to transform
raw webpage content into structured data using an underlying Language Model (LLM).

Key Components:
    - Webson: The main class offering methods to retrieve webpage content and "cast" it to a structured format.
    - Asynchronous and synchronous methods: Use Playwright for headless browser automation and IntelliBricks for LLM integration.

Usage Example:
    >>> from intellibricks.llms import Synapse
    >>> from webson import Webson
    >>>
    >>> # Create a Webson instance with a Synapse LLM
    >>> llm = Synapse.of("google/genai/gemini-pro-experimental")
    >>> webson = Webson(llm=llm, timeout=5000)
    >>>
    >>> # Retrieve the HTML content of a webpage synchronously
    >>> html = webson.get_contents("https://example.com")
    >>> print(html)
    >>>
    >>> # Cast the webpage to a structured data model
    >>> import msgspec
    >>> class PageSummary(msgspec.Struct):
    ...     title: str
    ...     description: str
    >>>
    >>> summary = webson.cast("https://example.com", to=PageSummary)
    >>> print(summary)
"""

from __future__ import annotations

from typing import TYPE_CHECKING, cast, Any, Sequence

import msgspec
from architecture import log
from architecture.utils.functions import run_sync
from intellibricks.llms import Synapse, SynapseCascade, SynapseProtocol
from intellibricks.llms.util import get_struct_from_schema
from markdownify import markdownify as md
from playwright.async_api import async_playwright, Browser
from playwright.async_api._generated import Playwright as AsyncPlaywright

from ._const import SYSTEM_PROMPT
from ._types import JsonSchema
from ._functions import find_urls_in_string

if TYPE_CHECKING:
    from openai import OpenAI

# Create a debug logger for internal tracing
debug_logger = log.create_logger(__name__, level=log.DEBUG)


class Webson(msgspec.Struct):
    """
    A class for extracting webpage contents and converting them into structured data using an LLMs.

    Attributes:
        llm (SynapseProtocol):
            The underlying LLM interface used for generating structured outputs.
        timeout (int | None):
            Optional timeout (in milliseconds) for page loads in Playwright.
    """

    llm: SynapseProtocol
    """The synapse weaver used to perform its operations."""

    timeout: int | None = None
    """Timeout (in milliseconds) to use for page loads. If None, the default timeout is used."""

    @classmethod
    def create(cls, llm: SynapseProtocol | OpenAI | None) -> Webson:
        """
        Creates a Webson instance from an LLM instance.

        This factory method accepts an instance of either Synapse, SynapseCascade, or OpenAI.
        When an OpenAI instance is provided, it wraps it as a Synapse using the 'gpt-4o' model.

        Args:
            llm (SynapseProtocol | OpenAI): The LLM instance to be used.

        Returns:
            Webson: A new instance of Webson configured with the appropriate llm.

        Example:
            >>> from intellibricks.llms import Synapse
            >>> from webson import Webson
            >>> llm = Synapse.of("google/genai/gemini-pro-experimental")
            >>> webson = Webson.create(llm)
        """
        match llm:
            case Synapse():
                _llm = llm
            case SynapseCascade():
                _llm = llm
            case OpenAI():
                _llm = Synapse(model="gpt-4o", api_key=llm.api_key)
        # Return a new Webson instance (assuming additional initialization as needed)
        return cls(llm=_llm)

    def get_contents(self, url: str) -> str:
        """
        Synchronously retrieves the entire HTML content of a webpage.

        Internally, this method calls the asynchronous version (`get_contents_async`)
        and blocks until the content is retrieved.

        Args:
            url (str): The URL of the webpage to retrieve.

        Returns:
            str: The HTML content of the webpage.

        Example:
            >>> html = webson.get_contents("https://example.com")
            >>> print(html)
        """
        return run_sync(self.get_contents_async, url)

    async def get_contents_async(self, url: str, browser: Browser | None = None) -> str:
        """
        Asynchronously retrieves the entire HTML content of a webpage using Playwright.

        This method launches a headless Chromium browser (if browser not provided), opens a new page,
        navigates to the specified URL, and returns the page's HTML content.

        Args:
            url (str): The URL of the webpage to retrieve.
            browser (Browser | None): Optional Playwright browser instance to reuse.

        Returns:
            str: The HTML content of the webpage.

        Example:
            >>> contents = await webson.get_contents_async("https://example.com")
            >>> print(contents)
        """
        if browser is None:
            async with async_playwright() as p:
                contents = await self._get_contents(url, p)
                debug_logger.debug(f"Page contents: {contents[:100]}")
                return contents
        else:
            contents = await self._get_contents_with_browser(url, browser)
            debug_logger.debug(f"Page contents: {contents[:100]}")
            return contents

    async def _get_contents(self, url: str, playwright: AsyncPlaywright) -> str:
        """Helper method to handle content retrieval with a new Playwright instance."""
        chromium = playwright.chromium
        browser = await chromium.launch(headless=True)
        try:
            return await self._get_contents_with_browser(url, browser)
        finally:
            await browser.close()

    async def _get_contents_with_browser(self, url: str, browser: Browser) -> str:
        """Helper method to retrieve content using an existing browser instance."""
        page = await browser.new_page()
        try:
            await page.goto(url, timeout=self.timeout)
            debug_logger.debug("Getting page contents")
            return await page.content()
        finally:
            await page.close()

    def cast[T: msgspec.Struct](
        self, typ: type[T], url: str, *, browser: Browser | None = None, details: str | None = None
    ) -> T:
        """
        Synchronously casts a webpage's content into a structured output.

        This method retrieves the page's HTML content, converts it to markdown,
        and then invokes the underlying LLM (via `cast_async`) to produce structured data.

        Args:
            url (str): The URL of the webpage to cast.
            to (type[T]): The msgspec.Struct subclass type that defines the desired output schema.

        Returns:
            T: An instance of the structured output as defined by the `to` type.

        Example:
            >>> import msgspec
            >>> class PageData(msgspec.Struct):
            ...     title: str
            ...     content: str
            >>> data = webson.cast("https://example.com", to=PageData)
            >>> print(data.title)
        """
        return run_sync(self.cast_async, typ, url, browser=browser, details=details)

    async def cast_async[T: msgspec.Struct](
        self, typ: type[T], url: str, *, browser: Browser | None = None, details: str | None = None
    ) -> T:
        """
        Asynchronously casts a webpage's content into a structured output.

        The method performs the following steps:
            1. Retrieves the raw HTML content of the specified URL.
            2. Converts the HTML content to markdown for improved text processing.
            3. Uses the underlying LLM to generate a structured output based on the provided schema.

        Args:
            typ (type[T]): The msgspec.Struct subclass type defining the desired output structure.
            url (str): The URL of the webpage to cast.

        Returns:
            T: An instance of the structured output as defined by the `to` type.

        Example:
            >>> structured_data = await webson.cast_async(PageData, "https://example.com")
            >>> print(structured_data)
        """
        # Retrieve the raw HTML page contents asynchronously.
        page_contents = await self.get_contents_async(url, browser=browser)

        # Convert the HTML to markdown for easier parsing.
        page_md = cast(str, md(page_contents))
        
        extra = f"## Extra details: \n\n {details}" if details else ""

        # Use the LLM to generate a structured response based on the markdown.
        completion = await self.llm.complete_async(
            f"<page>\n\n{page_md}\n\n</page> \n\n {extra}",
            system_prompt=SYSTEM_PROMPT,
            response_model=typ,
            timeout=self.timeout
        )
        return completion.parsed

    def suggest_schema_from_query(self, query: str) -> dict[str, Any]:
        """
        Synchronously extracts a structured JSON schema from a user's query.

        Given a query (e.g., "go to https://amazon.com and give me title, price, category
        of each product on the homepage"), this method asks the LLM to generate a JSON schema
        that defines the expected output structure (without including URLs).

        Args:
            query (str): The natural language query describing the desired data extraction.

        Returns:
            dict[str, Any]: A JSON schema as a Python dictionary.

        Example:
            >>> schema = webson.suggest_schema_from_query(
            ...     "go to https://amazon.com and extract title, price, and category for each product"
            ... )
            >>> print(schema)
        """
        return run_sync(self.suggest_schema_from_query_async, query)

    async def suggest_schema_from_query_async(self, query: str) -> dict[str, Any]:
        """
        Asynchronously extracts a structured JSON schema from a user's query.

        This method sends the query to the LLM with a system prompt that instructs
        it to analyze the query and generate a JSON schema that represents the desired structure.
        If the query contains a URL (e.g., "go to https://amazon.com"), that URL is omitted from the schema.

        Args:
            query (str): The natural language query describing the desired extraction.

        Returns:
            dict[str, Any]: A JSON schema as a Python dictionary.

        Example:
            >>> schema = await webson.suggest_schema_from_query_async(
            ...     "go to https://amazon.com and list title, price, and category of products"
            ... )
            >>> print(schema)
        """
        completion = self.llm.complete(
            f"<query>\n\n{query}\n\n</query>",
            system_prompt=(
                "You are a helpful assistant. Your task is to analyse the user query and try to extract "
                "a structured json schema based on what the user is asking for. If you find an url in the query, "
                'like "go to https://...", you should not include this url in the final schema.'
            ),
            response_model=JsonSchema,
        )

        json_schema = completion.parsed.schema
        return json_schema

    def query_to_struct(self, query: str) -> Sequence[tuple[str, type[msgspec.Struct]]]:
        """
        Synchronously performs a high-level cast operation based on a natural language query.

        This method allows the user to describe what data they need from one or more websites.
        It automatically extracts URLs, generates a JSON schema from the query, and casts each webpage
        into a structured output. For more granular control, consider using `cast`/`cast_async` directly.

        Args:
            query (str): A natural language query that includes one or more URLs and specifies the desired data fields.

        Returns:
            Sequence[tuple[str, type[msgspec.Struct]]]:
                A sequence of tuples, each containing:
                    - a URL (str) extracted from the query, and
                    - the corresponding structured output (an instance of a msgspec.Struct subclass).

        Example:
            >>> results = webson.query_to_struct(
            ...     "Extract product details (title, price, rating) from https://amazon.com and https://walmart.com."
            ... )
            >>> for url, output in results:
            ...     print(url, output)
        """
        return run_sync(self.query_to_struct_async, query)

    async def query_to_struct_async(
        self, query: str
    ) -> Sequence[tuple[str, type[msgspec.Struct]]]:
        """
        Asynchronously performs a high-level cast operation based on a natural language query.

        The method follows these steps:
            1. Extracts a JSON schema from the query using the underlying LLM.
            2. Converts the JSON schema into a `msgspec.Struct` subclass via `get_struct_from_schema`.
            3. Extracts all URLs present in the query using `find_urls_in_string`.
            4. For each URL, retrieves the webpage content and casts it into the structured format using `cast_async`.

        The final result is a sequence of tuples, each containing the URL and its corresponding structured output.

        Args:
            query (str): A natural language query specifying one or more URLs and the desired output structure.

        Returns:
            Sequence[tuple[str, type[msgspec.Struct]]]:
                A sequence of tuples where each tuple consists of:
                    - a URL (str) extracted from the query, and
                    - the structured output (an instance of a msgspec.Struct subclass) obtained from that URL.

        Example:
            >>> results = await webson.query_to_struct_async(
            ...     "Extract product info (title, price, rating) from https://amazon.com."
            ... )
            >>> for url, output in results:
            ...     print(url, output)
        """
        # Extract the JSON schema from the query.
        # (Make sure that 'suggest_schema_from_query' is implemented or use 'suggest_schema_from_query' instead.)
        json_schema = self.suggest_schema_from_query(query)
        struct: type[msgspec.Struct] = get_struct_from_schema(json_schema)
        # Extract the URLs from the query using a helper function.
        urls = find_urls_in_string(query)
        # Retrieve and cast the webpage asynchronously.
        casted = [(url, await self.cast_async(url, to=struct)) for url in urls]
        return casted

```


## Metadata File: webson-0.1.6/README.md
```
# Webson ðŸ•¸ï¸

**Turn any webpage into structured outputs!** âš¡ï¸  
*Extract data from any website with the power of AI.*

---

## âœ¨ Overview

Webson is a cutting-edge tool that transforms webpages into structured data models â€” all with just a few lines of code. No more manual scraping or complex parsers! With Webson, you can effortlessly convert HTML into meaningful, actionable insights using state-of-the-art Language Models (LLMs) from IntelliBricks and robust automation powered by Playwright.

---

## ðŸŽ¯ Key Features

- **ðŸ¦¾ Intelligent Data Extraction:**  
  Convert webpages into structured data using your own defined models.  
  *(Say goodbye to messy HTML!)*

- **ðŸ’¬ Chat Casting:**  
  Simply tell Webson what you need in plain language, and it will extract and structure the data for you.  
  *(Example: "Extract product details from https://amazon.com and shopee.com including title, price, and rating.")*

- **âš¡ï¸ Seamless Integration:**  
  Built on top of [IntelliBricks](https://arthurbrenno.github.io/intellibricks/) and [Playwright](https://playwright.dev/python/docs/intro) â€” enjoy a Python-first approach without the boilerplate.

- **ðŸ“Š Structured Outputs:**  
  Define your output schemas with `msgspec.Struct` and get data back in a ready-to-use, strongly typed format.

---

## ðŸš€ Installation

Install Webson and its dependencies via pip:

```bash
pip install webson
```

**Important:** Webson relies on [Playwright](https://playwright.dev/python/docs/intro) for web automation. This happens because we all know that many pages rely on things that only happen in a browser, like loading stripts, styles, etc. Follow these steps to install Playwright and its browser dependencies:

1. **Install Playwright:**

    ```bash
    pip install playwright
    ```

2. **Install Browser Binaries:**

    ```bash
    playwright install
    ```

Now youâ€™re all set to transform any webpage into structured intelligence!

---

## ðŸ”§ Usage Examples

### 1. Casting a Webpage into a Structured Model

Define your own data model and cast a webpageâ€™s content into it:

```python
import msgspec
from intellibricks.llms import Synapse
from webson import Webson
from typing import Annotated

# Define your desired structured model
class PageSummary(msgspec.Struct):
    title: str
    summary: Annotated[
      str,
      msgspec.Meta(
        description="A short summary of the page")
    ]

# Initialize your LLM (using IntelliBricks Synapse) and Webson
llm = Synapse.of("google/genai/gemini-pro-experimental")
webson = Webson(llm=llm, timeout=5000)

# Cast the webpage content into your structured model
structured_data = webson.cast(PageSummary, "https://example.com")
print(f"Title: {structured_data.title}")
print(f"Content: {structured_data.summary}")
```

### 2. High-Level Query to Struct

Simply describe what you need and let Webson do the heavy lifting:

```python
from intellibricks.llms import Synapse
from webson import Webson

# Initialize your LLM and Webson instance
llm = Synapse.of("google/genai/gemini-pro-experimental")
webson = Webson(llm=llm, timeout=5000)

# Use natural language to instruct Webson on what data to extract
results = webson.query_to_struct(
    "Extract product info from https://amazon.com and https://www.walmart.com/ including title, price, and rating."
)
for url, output in results:
    print(url, output)
```

---

## âš™ï¸ How It Works

1. **Webpage Automation:**  
   Webson uses Playwright to open webpages in a headless browser and retrieve the HTML content.

2. **Markdown Conversion:**  
   The raw HTML is converted into Markdown for improved text processing and parsing.

3. **LLM-Powered Casting:**  
   The transformed Markdown is sent to your LLM (via IntelliBricks) which then returns structured data based on your specified schema.

---

## ðŸ¤ Contributing

We welcome contributions to make Webson even more awesome!  
If you encounter any issues or have ideas for new features, please open an issue or submit a pull request on our [GitHub repository](https://github.com/your-repo/webson).

---

## ðŸ“œ License

This project is licensed under the [APACHE 2.0 License](LICENSE).

---

```


## Metadata File: webson-0.1.6/pyproject.toml
```
[project]
name = "webson"
version = "v0.1.6"
description = "Turn any webpage into structured outputs!"
readme = "README.md"
requires-python = ">=3.13"
dependencies = ["architecture>=0.5.44", "intellibricks>=0.7.24", "markdownify>=0.14.1", "msgspec>=0.19.0", "playwright>=1.49.1", "requests>=2.32.3"]

[[project.authors]]
name = "Arthur Brenno"
email = "64020210+arthurbrenno@users.noreply.github.com"

[project.scripts]
webson = "webson:main"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[dependency-groups]
dev = ["mypy>=1.14.1", "openai>=1.61.0", "pyfiglet>=1.0.2", "pytest>=8.3.4", "questionary>=2.1.0", "rich>=13.9.4", "toml>=0.10.2", "tomlkit>=0.13.2"]

```
